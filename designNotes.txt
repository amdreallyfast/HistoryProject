Click-and-drag:
	For pins, I found it more user friendly to surround the pins with a bounding box that is easy to click than to have the user try to click on the pin itself. 
	However, this made it difficult to determine where the mouse was trying to put the pin because the raycaster intersected the bounding box noticeably before it intersected the globe.
	When starting to click-and-drag a pin, I couldn't have the position jump to the raycaster's intersection with the globe because that kind of snapping to the cursor didn't feel right.
	So I made a quaternion rotator from where the click-and-drag began to the cursor's current position on the globe, and I made another quaternion rotor from the raycaster's initial intersection with the globe to where it intersected with the bounding box.
	With these two rotors, I was able to apply the click-and-drag logic smoothly to the bounding box.
	And then I had to associate the pin with the bounding box, which I did in PinMesh.jsx.

	Move PinMesh:
		Cannot simply rotate the quaternion. 
		The pin was created at the globe origin, translated to the surface, and then rotated to point at the center of the globe. 
		The quaternion rotator is applied after translation, so any attempts to rotate the pin's quaternion will simply result in the pin spinning on the surface of the globe.
		
		To rotate:
			Calculate vector from earth origin to pin origin.
			Apply the quaternion rotor from the cursor movement over the globe, and then apply the quaternion rotor from the raycaster's initial globe intersection to its initial intersection with the bounding box.
			Set the pin mesh's position and bounding box mesh's position to the rotated vector.

		PrimaryPOI pin:
			Same logic as above. Nothing special.
		
		Region boundary pin:
			Complications:
				When moving, they had to retrigger the calculation of the region mesh.
				I also wanted to be able to subdivide the region pins to get more of them, which will allow for more intricate borders.
			
				The latter meant that I had regenerate the pin meshes when the array of region boundary pins changed.
				I toyed with regenerating all pins whenever any of them moved, and that resulted in the region boundary pin meshes appearing to move on click-and-drag, but they were actually being re-created, and this meant that they ignored the pin movement logic in PinMesh, which the PrimaryPOI pin _was_ following.
			
			Solution:
				I didn't like the pins following different logic, so I opted instead to use a simple counter in the state machine called "regionBoundaryPinHasMoved", and whenever I moved a region boundary pin, I incremented the counter by 1, which would trigger the regeneration of the region mesh without re-creating the meshes from scratch, and then they followed the pin movement logic in PinMesh, just like the PrimaryPOI pin.
				
				Subdividing the region boundary pin array will generate new pins, which _should_ change the array and trigger the drawing of new pin meshes and generate a new region mesh.
			
			Move single pin:
				Same logic as PrimaryPOI pin.
			
			Move whole region:
				Move geometry without checking if you are a region boundary pin. 
				When moving the whole region, move _all_ pins.
			
		Move whole region:
			Whole region is generated using spherical math, with every point being calculated and set rather than transformed from an origin. 
			That is, the geometry is not a constant (like the pins) and so should not be moved by transforms. Transforms are independent of vertices, so if you update the vertices, the transforms are applied to the new vertices, which moves them away from where they were calculated that they should be.
			Therefore, do not move it per se, but rather rely on the movement of the region boundary pins to update the region boundaries, and then react to that to re-create the mesh.

Globe:
	TODO: 
		figure out how to convert 3D points on the surface of a globe to a 2D space, _then_ run the triangulation algorithms
		
		Progress:
			Discard.
			
			I remember trying that, but I still couldn't get past the trouble of the need to wrap around at the poles. I had to use polar coordinates to interact with a globe.
	
	TODO:
		Initial idea 2024 sometime
		Mon, 9/1/2025
		Create "clickable line mesh" object
		Purpose:
			Use in boundary line and timeline later
	
	TODO:
		Initial idea 2024 sometime
		Mon, 9/1/2025
		Create "boundary line" and incorporate on top of the mesh the mesh
		Prerequisite:
			"clickable line mesh"
		When selected, can be:
			moved (technically moves the boundary pins on either side)
			subdivided:
				Create new boundary pin
				Create 2x new "boundary line" objects between the three pins (A <--> B <--> C)
				Remove current "boundary line" object
		
		Progress:
			??
	TODO:
		Initial idea 2024 sometime
		Mon, 9/1/2025
		Create "timeline" object to be rendered on the surface of the globe
		When clicked, it will select a timeline in the backend
		
		Progress:
			??
			This will be later
	
	TODO: 
		Initial idea 2024 sometime
		Mon, 9/1/2025
		Implement "Command" pattern so that the user can CTRL-Z the last edit

	TODO: 
		Initial idea 2024 sometime
		Mon, 9/1/2025
		stateSliceEditPoi: delete whereLatLongArr: [],  
		
		Progress:
			??done when??
			Done (when checked Mon, 9/1/2025)

	TODO: 
		Initial idea 2024 sometime
		Mon, 9/1/2025
		Scene: 
			useEffect: 
				editState.editModeOn: 
					set edit state info based on currently selected POI info

	TODO: 
		Initial idea 2024 sometime
		Mon, 9/1/2025
		Scene: 
			move mouse hover logic from scene to MouseHandler
			useEffect: mouseState.cursorRaycastIntersections.firstNonGlobe
			useEffect: mouseState.cursorRaycastIntersections.globe

	TODO: 
		Initial idea 2024 sometime
		Mon, 9/1/2025
		MouseHandler: 
			useEffect: 
				mouseState.mouseUp: 
					if time is short enough, then consider hovering over the globe or not. If hovering over globe, consider lat/long changes (perhaps the user is trying to click-and-drag the screen to rotate the globe). Else just check for screen space positioning
		
		Progress:
			done ??when??

	TODO: new state: 
		Initial idea ??when??
		Mon, 9/1/2025

		interactableMeshIds (based on ThreeJS' mesh.id)
		when a mesh finishes creation, add the meshId to the array
		when a mesh is deleted, remove the meshId from the array 
			??what "use" function would I call for this??
		
		Progress:
			done (2023 sometime)
			C:\GitHub\HistoryProject\npmfrontend\src\GlobeSection\Scene.jsx, line 63
	
	TODO: 
		Initial idea ??when??
		Mon, 9/1/2025
		simple "star field" effect: Make each star vary brightness, starting with a random delay (so that they don't all vary brightness simultaneously)
		
		Progress:
			??
	
	TODO: 
		bug to reactThreeFiber: "points" does not record "name" when provided
		
		Progress:
			??

DetailsSection
	TODO:
		Mon, 9/1/2025
			Create 2x event types:
				RecordsCreated
				EverythingElse
			
			A "RecordsCreated" event requires no source. It will _be_ the source.
			An "EverythingElse" event requires at least one "RecordsCreated" event. It is everything other than the creation of the record of it.
			
		Progress:
			C:\GitHub\HistoryProject\npmfrontend\src\AppState\stateSliceEditPoi.jsx
				Update this file and add field to initialState: "eventType", default value "EverythingElse". Add a function field to createSlice similar to setImageDataUrl, in which "eventType" is extracted from the payload and set in the state.

			C:\GitHub\HistoryProject\npmfrontend\src\AppState\stateSliceEditPoi.jsx
				Create a new file in this folder called "EditEventType.jsx", similar in appearance and style to EditEventSummary.jsx, but instead a textarea, use a radio button labeled "Event type" with two options: "Records created" and "Everything else". Use the latter as default.

				Add this component to EditEvent, just under the header

	
	TODO:
		Mon, 9/1/2025
			When creating an "EverythingElse" event, "Add Source" will be required so that the source will be linked to the event that recorded it.
			If the source is not yet recorded, then the "Add Source" interface shall have a "Create source" button.
			If selected, the "Create source" button will open a new interface "tab" over the "Create event" interface, locked to type "RecordsCreated"
			When finished creating the source, the interface will return to the "Create event" interface, and the new source will be automatically added.
		
		Progress:
			??
	
	TODO:
		Mon, 9/1/2025
			C:\GitHub\HistoryProject\npmfrontend\src\AppState\stateSliceEditPoi.jsx
				setRevisionAuthor(...)
					Should be set automatically according to the current user
		
		Progress:
			??
		
Create a new state file in the current folder called "stateSliceEditEvent.jsx" using similar syntax to "stateSliceEditPoi.jsx". I want it to have an initialState with the following fields:
"eventId", guid. This will be a constant across all revisions of this event
"revisionId", guid. This represents a specific instance of an event
"revisionAuthor", string, and will default to "TestingAuthor" for now
"title", string, default null
"eventStartYear", 
"tags", array of strings, default to empty array
"imageDataUrl", null string.
"summary", null string

Add brief comments to each field for expected type and whether or not it is required.


